
== Planeación del desarrollo y requisitos de seguridad

La presente sección reúne los elementos esenciales que deben considerarse durante la planeación del desarrollo y la definición de requisitos de seguridad. Se abordan actividades fundamentales como la elicitación de requisitos, la evaluación del contexto organizacional, la identificación de amenazas y riesgos, la consulta de marcos normativos aplicables y el uso de técnicas formales de modelado de amenazas.

La planeación constituye la fase inicial del ciclo de vida del desarrollo de una API. En esta etapa, se establece el propósito de la API, así como los casos de uso y los recursos necesarios para su construcción. Se realiza la definición de los requisitos operativos, de negocio y de seguridad, y se identifican los equipos encargados de guiar la API a lo largo de las fases posteriores [17].

Según [18], una planeación adecuada comprende el mapeo de recursos, operaciones y escenarios de negocio antes de la implementación. Por su parte, [19] resalta la importancia de incluir la estrategia de la API, las decisiones arquitectónicas de alto nivel y la creación de contratos que describan el comportamiento esperado de la misma.

Esta etapa abarca los requisitos tanto funcionales (las funcionalidades que la API debe ofrecer) como los no funcionales (atributos de calidad que determinan su comportamiento). En este último grupo, la seguridad desempeña un papel crítico, al requerir la identificación de posibles riesgos, el establecimiento de mecanismos de autenticación y autorización, el cumplimiento normativo, la selección de herramientas y demás prácticas que acompañan el ciclo de desarrollo.

Las prácticas reportadas en la literatura para esta fase se presentan en la siguiente tabla:


[cols="1,2,1", options="header"]
|===
|Nombre |Descripción |Referencia

|Análisis del inventario
|Revisión de las APIs existentes en la organización con el objetivo de verificar el cumplimiento de los requerimientos del nuevo proyecto. Esta práctica permite evitar el desarrollo de funcionalidades redundantes y minimizar la complejidad innecesaria dentro del ecosistema de APIs.
|[20]

|Análisis de público objetivo
|Identificación de los usuarios previstos de la API y de los problemas específicos que se pretende resolver. Este análisis facilita la definición de casos de uso claros y asegura la alineación entre los objetivos técnicos y los objetivos de negocio.
|[20]

|Viabilidad técnica
|Evaluación de los recursos, tecnologías e infraestructura necesarios para el desarrollo, implementación, mantenimiento y operación a largo plazo de la API.
|[20]

|Definir políticas y responsabilidades
|Establecimiento de lineamientos que regulen la seguridad, gobernanza y cumplimiento normativo en el diseño y uso de la API, incluyendo la asignación de responsabilidades a los distintos actores involucrados en su ciclo de vida.
|[20]

|Definición de requisitos
|Documentación clara de los casos de uso y de los usuarios previstos de la API, asegurando que esta incorpore únicamente las funcionalidades necesarias y evitando tanto la sobrecarga como omisiones críticas.
|[8]

|Definición inicial de requisitos y preparación del entorno de trabajo
|Determinación de los requisitos operativos, de negocio y de seguridad de la API, así como identificación de los integrantes del equipo responsables de su desarrollo a lo largo de las fases del ciclo de vida. Esta práctica incluye la recomendación de establecer un entorno de colaboración desde el inicio, como un espacio de trabajo dedicado y un repositorio en GitHub conectado a un pipeline de integración continua (CI).
|[21]
|===

=== Elicitación y definición de requisitos

La elicitación de requisitos es el proceso mediante el cual se identifican las necesidades y restricciones de los distintos actores involucrados en un sistema de software. Este proceso implica descubrir lo que el cliente necesita y desea mediante enfoques bien definidos. Se trata de una actividad activa orientada a extraer los requisitos desde las partes interesadas, lo que puede implicar la formulación de preguntas y la aplicación de escucha activa. [22]

[TIP]
====
El objetivo principal de la elicitación de requisitos es recopilar información que permita definir requisitos claros, concisos, verificables, consistentes, completos y trazables.
====

Existen diversas técnicas que pueden emplearse para la elicitación de requisitos, tales como entrevistas, talleres, encuestas y observación directa. La elección de la técnica más adecuada depende del contexto del proyecto y de las características de los actores involucrados. Asimismo, pueden utilizarse herramientas como los casos de uso, las historias de usuario y las especificaciones funcionales, las cuales permiten capturar los requisitos de manera estructurada y facilitar su posterior análisis y validación. [22]


==== Requisitos funcionales

Los requisitos funcionales constituyen la especificación del comportamiento que un sistema debe exhibir bajo determinadas condiciones. En otras palabras, describen las funcionalidades que el producto debe implementar para permitir que los usuarios realicen sus tareas, satisfaciendo así los objetivos y necesidades del negocio [23].

Estos requisitos suelen redactarse en forma de declaraciones utilizando el verbo «deberá». Por ejemplo: «El pasajero deberá poder imprimir las tarjetas de embarque de todos los tramos de vuelo para los que haya realizado la facturación» [23].

En el contexto de la seguridad, un ejemplo de requisito funcional sería: «El cliente de la API deberá poder autenticarse mediante un token de acceso válido antes de consumir cualquier recurso protegido» [23].

==== Requisitos no funcionales

Además de los requisitos funcionales, existen los requisitos no funcionales, también conocidos como atributos o factores de calidad, requisitos de calidad de servicio o restricciones. Estos describen las características del producto en diversas dimensiones que resultan relevantes tanto para los usuarios como para los desarrolladores y el personal de mantenimiento. Entre estas dimensiones se incluyen el rendimiento, la seguridad, la disponibilidad y la portabilidad, entre otros [23].

===== Requisitos de seguridad asociados

Los requisitos de seguridad forman parte de los requisitos no funcionales. Un requisito de seguridad se define como una declaración que especifica una funcionalidad necesaria para garantizar que se satisfaga alguna de las propiedades de seguridad del software, tales como confidencialidad, integridad o disponibilidad.

Estos requisitos suelen derivarse de estándares de la industria, normativas legales y del análisis de vulnerabilidades previamente identificadas. Los requisitos de seguridad establecen nuevas características o amplían las existentes con el propósito de mitigar riesgos específicos o eliminar posibles vulnerabilidades [24].

Asimismo, los requisitos de seguridad proporcionan una base sólida de funcionalidad validada, que permite estandarizar los controles y las buenas prácticas de protección en el desarrollo de aplicaciones. Este enfoque favorece la reutilización de mecanismos de seguridad probados, en lugar de diseñar soluciones ad hoc para cada proyecto.

Entre los estándares disponibles, destaca la Norma de verificación de seguridad de aplicaciones  (Application Security Verification Standard, ASVS) de OWASP, el cual ofrece un catálogo estructurado de requisitos y criterios de verificación de seguridad. Dicho estándar puede emplearse como una fuente de referencia para definir requisitos de seguridad detallados durante el desarrollo de software.

A continuación, se presentan ejemplos de requisitos funcionales y su correspondiente relación con requisitos de seguridad.

[cols="1,1", options="header"]
|===
| Requisito funcional | Requisitos de seguridad

| Los usuarios podrán registrarse en la plataforma proporcionando su correo electrónico y contraseña.
| Las contraseñas deben almacenarse cifradas (ej. bcrypt) y la comunicación durante el registro debe ser vía HTTPS.

| Los usuarios podrán consultar su historial de transacciones financieras.
| Solo usuarios autenticados pueden acceder a su historial; se debe implementar control de acceso basado en roles y cifrado de datos en reposo.

| Los usuarios podrán descargar reportes en formato PDF desde el sistema.
| Los archivos PDF deben generarse de forma segura, sin incluir información de otros usuarios, y la descarga debe realizarse sobre HTTPS.
|===

==== Documentación de requisitos

La documentación de requisitos constituye un componente esencial del desarrollo de software, ya que describe de manera detallada lo que el sistema planificado deberá hacer y el modo en que se espera que funcione. Su propósito es servir como una referencia integral para todas las etapas del ciclo de vida del software. Esta documentación puede presentarse en forma de un documento de Especificación de Requisitos de Software (Software Requirements Specification, SRS).

===== Especificación de requisitos de software

La especificación de Requisitos de Software también puede denominarse especificación funcional, especificación del producto, documento de requisitos o especificación del sistema, aunque estos términos no siempre se emplean de manera uniforme en todas las organizaciones [22].

El SRS establece con precisión las funciones, capacidades y restricciones que debe cumplir un sistema de software. Este documento constituye la base para la planificación, el diseño, la codificación, las pruebas del sistema y la elaboración de la documentación para los usuarios. Su contenido debe describir de manera completa el comportamiento del sistema bajo distintas condiciones, evitando incluir detalles de diseño, implementación, pruebas o gestión del proyecto, excepto cuando se trate de restricciones conocidas [23].

Diversos actores dentro del proceso de desarrollo se benefician del SRS:

* Los clientes, el área de mercadotecnia y el personal de ventas lo utilizan para conocer el producto que se espera entregar.  
* Los gerentes de proyecto lo emplean para estimar el calendario, el esfuerzo y los recursos necesarios.  
* El equipo de desarrollo lo usa como guía principal para la construcción del sistema.  
* El equipo de pruebas lo utiliza para diseñar planes, casos y procedimientos de prueba.  
* El personal de mantenimiento y soporte recurre al SRS para comprender el propósito y las funciones de cada componente del sistema.  
* Los redactores técnicos basan los manuales de usuario y las guías de ayuda en el SRS y en el diseño de la interfaz de usuario.  
* El personal de capacitación emplea el SRS y la documentación de usuario para elaborar materiales educativos.  
* El área legal asegura que los requisitos cumplan con las leyes y regulaciones aplicables.  
* Los subcontratistas basan su trabajo en el SRS y pueden ser legalmente responsables de cumplirlo.  

Como repositorio principal de los requisitos del producto, el SRS debe ser exhaustivo. Ni los desarrolladores ni los clientes deben asumir la existencia de funcionalidades o atributos que no estén explícitamente documentados en el SRS, ya que solo los requisitos acordados deben considerarse comprometidos para su implementación.

No es necesario completar el SRS de todo el producto antes de iniciar el desarrollo; sin embargo, es fundamental documentar los requisitos correspondientes a cada incremento antes de construirlo. El desarrollo incremental resulta apropiado cuando los interesados no pueden identificar todos los requisitos desde el inicio o cuando es prioritario entregar funcionalidad al usuario en etapas tempranas.

[TIP]
====
Trabajar a partir de un conjunto de requisitos acordado reduce la posibilidad de malentendidos y de reprocesos innecesarios [23].

====

//TODO: Incluir enlace a ejemplo de SRS de nuestro caso de estudio

==== Validación y trazabilidad de requisitos

La trazabilidad de los requisitos constituye un elemento esencial dentro del aseguramiento de la calidad y la gestión de proyectos de software. Según [23], un requisito trazable puede vincularse tanto hacia atrás —hacia su origen— como hacia adelante —hacia los requisitos derivados, los elementos de diseño, el código que lo implementa y las pruebas que verifican su correcta implementación—.  

Los requisitos trazables se identifican mediante identificadores únicos y persistentes, y se redactan de manera estructurada y granular. Es recomendable evitar la combinación de múltiples requisitos en un solo enunciado, dado que cada requisito puede estar asociado a distintos componentes del desarrollo. Aunque lograr una especificación perfecta es improbable, aplicar estos principios durante la redacción y revisión de requisitos contribuye a generar especificaciones más claras, completas y alineadas con los objetivos del proyecto [23].  

===== Beneficios de la trazabilidad de requisitos

El seguimiento de los requisitos a lo largo del ciclo de vida del proyecto ofrece múltiples beneficios, entre los que destacan los siguientes:

* *Detección de requisitos innecesarios:* permite identificar requisitos funcionales que no se relacionan con los requisitos de usuario o de negocio y, por lo tanto, podrían resultar innecesarios.  
* *Certificación y cumplimiento:* la información de trazabilidad puede emplearse para certificar productos críticos en materia de seguridad, demostrando que todos los requisitos fueron implementados. Asimismo, facilita evidenciar el cumplimiento de normativas aplicables, especialmente en sectores como salud y servicios financieros.  
* *Análisis de impacto de cambios:* la trazabilidad permite identificar los elementos del sistema afectados por la adición, modificación o eliminación de un requisito específico, reduciendo el riesgo de omisiones.  
* *Mantenimiento:* disponer de información de trazabilidad confiable facilita la actualización del sistema frente a cambios en políticas corporativas o regulaciones. Una tabla que muestre la relación entre reglas de negocio, requisitos, diseño y código simplifica la implementación de modificaciones de forma correcta y completa.  
* *Seguimiento del proyecto:* el registro de datos de trazabilidad durante el desarrollo proporciona una visión clara del estado de implementación de la funcionalidad planificada. Los enlaces ausentes indican productos de trabajo pendientes.  
* *Reingeniería:* la trazabilidad permite mapear las funciones de un sistema existente hacia los requisitos y componentes del nuevo sistema que lo reemplazará.  
* *Reutilización:* la trazabilidad facilita la identificación de paquetes de requisitos, diseños, código y pruebas relacionados, promoviendo la reutilización de componentes.  
* *Pruebas:* cuando una prueba falla, los vínculos entre los casos de prueba, los requisitos y el código permiten orientar a los desarrolladores hacia las áreas más probables donde se origina el defecto.  

Si bien muchos de estos beneficios se manifiestan a largo plazo, su implementación contribuye a reducir los costos globales del ciclo de vida del producto. No obstante, también puede incrementar los costos iniciales de desarrollo debido al esfuerzo requerido para recopilar y mantener la información de trazabilidad. En este sentido, la trazabilidad de requisitos debe considerarse una inversión que incrementa la probabilidad de entregar un producto mantenible y conforme a los requisitos del cliente.  

El esfuerzo necesario para establecer la trazabilidad es menor cuando la información se recopila de manera progresiva durante el desarrollo. En cambio, realizar este proceso sobre un sistema ya finalizado puede resultar considerablemente más costoso y laborioso [23].  

===== Matriz de trazabilidad de requisitos

En este contexto, existen diversas herramientas que permiten establecer relaciones entre cada requisito del producto y su origen. Una de las más utilizadas es la matriz de trazabilidad de requisitos, la cual constituye una cuadrícula que vincula los requisitos del producto con los entregables que los satisfacen.  

La implementación de una matriz de trazabilidad permite garantizar que cada requisito aporte valor al negocio, al vincularlo directamente con los objetivos comerciales y del proyecto. Asimismo, proporciona un medio estructurado para realizar el seguimiento de los requisitos a lo largo del ciclo de vida del proyecto, asegurando que los requisitos aprobados en la documentación inicial se vean reflejados en el producto final.  

De igual manera, la matriz ofrece un marco para gestionar los cambios en el alcance del producto, manteniendo la coherencia y trazabilidad entre los elementos del sistema [22].  

Los elementos que pueden ser objeto de trazabilidad incluyen, entre otros:

* Necesidades, oportunidades, metas y objetivos comerciales;  
* Objetivos del proyecto;  
* Alcance del proyecto y entregables de la estructura de desglose del trabajo (Work Breakdown Structure, WBS);  
* Diseño del producto;  
* Desarrollo del producto;  
* Estrategia y escenarios de prueba;  
* Requisitos de alto nivel y sus correspondientes requisitos detallados.  

Los atributos asociados a cada requisito pueden registrarse dentro de la matriz de trazabilidad. Estos atributos aportan información clave sobre el requisito, tales como:  

* Identificador único;  
* Descripción textual del requisito;  
* Justificación de su inclusión;  
* Propietario o responsable;  
* Fuente;  
* Prioridad;  
* Versión;  
* Estado actual (activo, cancelado, diferido, agregado, aprobado, asignado, completo);  
* Fecha de actualización del estado.  

Adicionalmente, pueden incluirse atributos que contribuyan a verificar la satisfacción de las partes interesadas, tales como los criterios de estabilidad, complejidad y aceptación.

//TODO: Incluir ejemplo de matriz de trazabilidad

=== Evaluación organizacional y su relación con la seguridad

La seguridad de una API no depende exclusivamente de mecanismos técnicos, sino también de la cultura organizacional que sustenta su desarrollo y operación. La cultura de seguridad se entiende como el conjunto de valores que determinan la forma en que los individuos perciben y abordan la seguridad dentro de la organización. Esta cultura se ve influida por las metas institucionales, la estructura organizativa, las políticas, los procesos y el liderazgo, así como por las relaciones con socios, proveedores y otros actores externos [25].

La cultura de ciberseguridad abarca asimismo las actitudes, conocimientos, normas y valores de los empleados en relación con la seguridad. Su efectividad no depende únicamente de políticas o procesos, sino de la alineación entre factores organizacionales (liderazgo, procesos, normas) y factores individuales (actitudes, conocimientos, comportamientos). La inversión en una cultura sólida fortalece la seguridad técnica de las APIs, genera confianza digital, mejora la reputación organizacional y promueve la adopción de comportamientos seguros en el trabajo cotidiano [26].

En entornos con una cultura de seguridad consolidada, los equipos perciben la seguridad como un esfuerzo colectivo y colaborativo que respalda las actividades diarias. Según [25], los principales beneficios incluyen:

* Mayor propensión de los empleados a identificar problemas y proponer mejoras, fortaleciendo la resiliencia.
* Facilita la comunicación abierta sobre incidentes sin temor a represalias.
* Mejora del bienestar y la retención del personal, al fomentar la inclusión y explicar claramente el propósito de las medidas de seguridad.

Para consolidar esta cultura, se recomienda complementar las prácticas organizacionales con certificaciones reconocidas, tales como ISO 27001 y Fundamentos cibernéticos (Cyber Essentials), que establecen estándares, procesos y políticas destinados a incrementar la resiliencia cibernética de la organización.

Un enfoque complementario es la estrategia de seguridad confianza cero (Zero Trust), basada en la premisa de que ninguna persona o dispositivo, tanto dentro como fuera de la red organizacional, debe considerarse de confianza de manera automática. Este modelo se fundamenta en tres principios esenciales [27]:

* Verificación de la confianza de todas las entidades.
* Aplicación del principio de privilegios mínimos.
* Implementación de una supervisión continua de la seguridad.

Estas prácticas organizacionales y modelos, como _Zero Trust_, resultan especialmente relevantes en el diseño y operación de APIs REST, dado que la exposición directa a internet incrementa la superficie de ataque y exige la alineación entre los aspectos técnicos y humanos dentro de una misma estrategia de seguridad.

=== Identificación de amenazas y riesgos

La identificación de amenazas y riesgos constituye una etapa crítica en el desarrollo seguro de APIs. Una amenaza se define como un evento o conjunto de circunstancias que puede comprometer los objetivos de seguridad de la API. Por ejemplo, un atacante que obtiene nombres y direcciones de la base de datos de clientes representa una amenaza para la confidencialidad de la información [3].

Las APIs se enfrentan a una amplia variedad de amenazas de seguridad, que incluyen ataques deliberados y fugas de datos involuntarias. Los usuarios no autorizados pueden explotar vulnerabilidades para acceder a datos confidenciales, interrumpir servicios o secuestrar sistemas. 

Entre las amenazas más frecuentes se encuentran los ataques de inyección, los ataques de tipo «hombre en medio» (man-in-the-middle, MITM) y los ataques de denegación de servicio distribuido (DDoS), diseñados para sobrecargar una API con tráfico malicioso [28]. Aunque el tipo y la frecuencia de las amenazas pueden variar según el modelo de API, los ataques más comunes deben considerarse para cualquier API que se diseñe o utilice [29].

La identificación de amenazas implica determinar los riesgos potenciales mediante herramientas y estrategias como listas de verificación, trazabilidad, análisis de puntos de entrada y evaluación de vulnerabilidades [30]. Este proceso permite relacionar los componentes del sistema con los elementos de la amenaza para su posterior validación y verificación.

Además de la identificación, la búsqueda activa de amenazas, conocida como  búsqueda de amenazas (threat hunting), consiste en la detección proactiva de amenazas desconocidas o previamente no detectadas dentro de la red de una organización. A diferencia del monitoreo de seguridad tradicional, que se enfoca en la detección y respuesta a amenazas conocidas mediante herramientas automatizadas, la búsqueda de amenazas persigue anticiparse a riesgos emergentes, permitiendo mitigarlos antes de que puedan generar daños significativos [28].

Por lo tanto, la labor del diseñador de una API no se limita a garantizar el cumplimiento de sus funciones requeridas, sino que también incluye una vigilancia constante del panorama de seguridad, con el objetivo de prevenir y mitigar posibles amenazas que puedan comprometer la integridad del sistema.

En secciones posteriores se describen metodologías específicas para el modelado de amenazas, las cuales facilitan la identificación y análisis sistemático de riesgos en el contexto del desarrollo de APIs REST seguras.

=== Referencias normativas y técnicas de seguridad para API

Los estándares de seguridad de API constituyen marcos y pautas diseñados para garantizar la protección de las APIs frente a posibles amenazas y vulnerabilidades. Estos estándares permiten a las organizaciones implementar medidas de seguridad consistentes y efectivas [31].

Estos marcos de seguridad abarcan diversos aspectos, incluyendo autenticación, autorización, cifrado de datos y gestión de sesiones. Su aplicación asegura que la comunicación a través de la API se adhiera a principios de seguridad, previniendo accesos no autorizados y posibles violaciones de datos [32].

Por otra parte, los protocolos de API definen los mecanismos de transmisión y protección de datos en la red. Establecen un lenguaje común y procedimientos que deben seguir tanto el emisor como el receptor, garantizando un intercambio seguro de información. Esto incluye el manejo seguro de tokens, cifrado de mensajes y validación de credenciales de identidad [32].

A continuación, se describen algunos de los principales estándares utilizados en la industria. Se aclara que la lista no es exhaustiva, y la selección del estándar adecuado dependerá del contexto, las necesidades de la aplicación y los requerimientos de la organización.

==== OAuth 2.0

OAuth 2.0 es uno de los marcos de autorización más utilizados para APIs web. Su objetivo principal es permitir que un usuario otorgue a una aplicación de terceros acceso limitado a sus recursos, sin necesidad de compartir sus credenciales. Este modelo se ha convertido en un estándar en la autorización de APIs y es ampliamente adoptado en entornos web, móviles y en la nube [8].

El funcionamiento básico de OAuth 2.0 consiste en que el usuario se autentica con un proveedor de identidad (por ejemplo, Google o Facebook) y concede permisos a la aplicación de terceros. Posteriormente, la aplicación obtiene un token de acceso, el cual se emplea para realizar solicitudes autorizadas a la API en nombre del usuario. Dicho token contiene scopes o alcances, que determinan el nivel de acceso permitido, como lectura o escritura sobre determinados recursos.

===== Consideraciones de seguridad

Al implementar OAuth 2.0, se deben tener en cuenta medidas de seguridad específicas para mitigar riesgos comunes asociados al manejo de tokens:

* Utilizar exclusivamente conexiones seguras (HTTPS) para la transmisión de tokens.
* Preferir tokens de corta duración acompañados de tokens de actualización (refresh tokens), a fin de reducir el riesgo en caso de robo de un token.
* Implementar mecanismos de revocación para invalidar tokens cuando sea necesario.

===== Ventajas

* Permite el acceso delegado sin necesidad de compartir credenciales del usuario.  
* Su amplia adopción promueve la estandarización en diversos servicios.  
* Facilita la integración entre aplicaciones heterogéneas (web, móviles y cloud).

===== Desventajas

* Requiere mecanismos seguros de almacenamiento y transmisión de tokens.  
* Introduce cierta complejidad en la gestión de tokens, especialmente con refresh tokens y su expiración.  
* Puede implicar sobrecarga en entornos con múltiples integraciones.

[TIP]
====
Se recomienda el uso de OAuth 2.0 en escenarios donde se requiera interacción con aplicaciones de terceros o integración con proveedores de identidad externos, así como en sistemas que manejen datos sensibles y deban delegar autorización sin exponer credenciales.  

Sin embargo, para aplicaciones internas o entornos con bajo riesgo de exposición, puede considerarse un mecanismo más simple, como autenticación mediante API keys o tokens firmados localmente.
====


==== JSON Web Token (JWT) 

Los JSON Web Tokens constituyen un formato de token estandarizado por RFC, ampliamente utilizado en protocolos de autorización como OAuth 2.0. Un JWT contiene claims, que son declaraciones con valores asociados, y está estructurado y codificado según estándares que garantizan que el token no pueda ser modificado y que pueda cifrarse adicionalmente [33].

[TIP]
====
Este tipo de tokens resulta especialmente útil para la transferencia de información en entornos con restricciones de espacio, como los encabezados de autorización HTTP.
====

A continuación se presenta un ejemplo de un JWT que podría ser utilizado en una API web REST para autenticar a un usuario:

[source,json]
----
{
    "iss": "http://secure/identity-provider",
    "sub": "123e4567-e89b-12d3-a456-426614174000",
    "aud": "Servicio-Usuarios",
    "exp": 1735689600,
    "nbf": 1735686000,
    "iat": 1735686000,
    "jti": "abc12345-6789-4567-890a-bcdef1234567"
}
----

En este token, las declaraciones (claims) incluidas son `iss`, `sub`, `aud`, `exp`, `nbf`, `iat` y `jti`. Estas son _claims_ reservadas definidas en el RFC de JWT. Aunque no son obligatorias, proporcionan un conjunto mínimo de información útil para la autenticación y autorización.

* `iss` (Issuer): Autoridad que emite el token, normalmente un proveedor de identidad.  
* `sub` (Subject): Identificador único del sujeto al que representa el token, por ejemplo, un usuario o una aplicación.  
* `aud` (Audience): Destinatario o servicio para el cual el token está destinado.  
* `exp` (Expiration time): Fecha y hora de expiración del token.  
* `nbf` (Not before): Momento a partir del cual el token es válido.  
* `iat` (Issued at): Fecha y hora de emisión del token.  
* `jti` (JWT ID): Identificador único del token, útil para evitar la reutilización.

===== Ventajas

* La autenticación sin estado (stateless) escala adecuadamente en sistemas distribuidos.  
* No requiere almacenar información de sesión en el servidor.  
* Permite control granular de los derechos de acceso mediante _claims_ del token.  
* Facilita la interoperabilidad entre servicios y aplicaciones heterogéneas.

===== Desventajas

* Si un token es robado, puede ser utilizado para suplantar al usuario.  
* La gestión de la expiración de tokens y los ciclos de renovación añade complejidad a la aplicación, tanto en la interfaz de usuario  (frontend) como en la parte del servidor (backend).  
* Se requiere cuidado en la implementación de la validación y revocación de tokens para evitar vulnerabilidades.

==== OpenID Connect (OIDC)

OAuth 2.0 proporciona un mecanismo para que el cliente acceda a APIs utilizando autenticación y autorización. Sin embargo, un requerimiento común es que el cliente también pueda conocer la identidad del propietario del recurso. Este es el propósito de OpenID Connect (OIDC): añadir una capa de identidad sobre OAuth 2.0.  

OIDC amplía el servidor de autorización OAuth 2.0 para que actúe también como proveedor de identidad, entregando al cliente un *ID token* (un JWT con _claims_ sobre el usuario) cuando se utiliza el alcance (scope) especial `openid`. Además, se pueden incluir _scopes_ adicionales como `profile`, `email`, `address` o `phone`, permitiendo obtener información más completa sobre el usuario [33].

Los flujos definidos por OIDC son tres: flujo del código de autorización (Authorization Code Flow), flujo implícito (Implicit Flow) y flujo híbrido (Hybrid Flow). El recomendado es el _authorization code flow_ junto con PKCE, ya que ofrece mayor seguridad.

[TIP]
====
OIDC y OAuth 2.0 no son lo mismo. OAuth 2.0 gestiona autorización para acceder a recursos, mientras que OIDC proporciona información de identidad del usuario. Ambos son complementarios.
====

[WARNING]
====
Nunca se deben usar los tokens de identificación (*ID tokens*) como si fueran tokens de acceso (*access tokens*). Los tokens de identificación (*ID tokens*) son de mayor duración y están diseñados únicamente para proporcionar información de identidad, no para acceder a recursos.
====

===== Ventajas

* Añade una capa de identidad estándar sobre OAuth 2.0.  
* Permite obtener información verificada del usuario mediante alcances (scopes) adicionales.  
* Compatible con JWT, lo que facilita la interoperabilidad.  
* Amplia adopción en entornos web y móviles.  

===== Desventajas

* Introduce complejidad adicional respecto a OAuth 2.0 puro.  
* Requiere que el proveedor de identidad soporte explícitamente OIDC.  
* Una implementación incorrecta puede dar lugar a filtración de datos sensibles.  


==== SAML 2.0

En entornos empresariales es común el uso de Marcado para Aserciones de Seguridad (Security Assertion Markup Language, SAML 2.0), un estándar abierto que transfiere afirmaciones (*assertions*) de identidad. Es ampliamente utilizado en escenarios de  inicio de sesión único (*single sign-on, SSO*), permitiendo que empleados accedan a aplicaciones externas mediante sus credenciales corporativas.  

Aunque SAML no está diseñado para usarse directamente en APIs REST, existe una extensión llamada _*SAML 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants*_, la cual permite a un cliente solicitar un token de acceso _*access token*_ usando SAML, siempre que el servidor de autorización tenga soporte para esta funcionalidad [33].  

===== Ventajas

* Muy utilizado en entornos corporativos para SSO.  
* Permite federación de identidad entre organizaciones.  
* Estándar maduro y con amplio soporte en sistemas empresariales.  

===== Desventajas

* No está alineado con el diseño de APIs REST modernas.  
* Mayor complejidad en comparación con OIDC.  
* Requiere integración específica con servidores que soporten el perfil SAML-OAuth2.  

[TIP]
====
SAML sigue siendo relevante en migraciones hacia OAuth 2.0 y OIDC, especialmente en organizaciones con infraestructuras legadas o en procesos de federación de identidad.
====


==== _Transport Layer Security_ (TLS)

_Transport Layer Security_ es un protocolo que opera sobre TCP/IP y proporciona funciones de seguridad esenciales para permitir la comunicación segura entre un cliente y un servidor. TLS garantiza la confidencialidad, integridad y autenticidad de los datos transmitidos, protegiendo las comunicaciones frente a ataques de tipo _man-in-the-middle_ [3, 34, 35 ].

TLS se implementa mediante un apretón de manos (handshake) inicial en el que el cliente autentica al servidor, garantizando que se conecta a la entidad correcta y no a un atacante. Durante este proceso, se negocian las versiones del protocolo y los algoritmos criptográficos a utilizar, así como las claves de cifrado que se emplearán para el resto de la sesión. La información transmitida posteriormente se cifra y autentica utilizando estas claves, asegurando que no pueda ser leída ni modificada por terceros [3, 35].

TLS es ampliamente utilizado en protocolos de API basados en HTTP, incluyendo REST y SOAP, para cifrar la comunicación entre clientes y servidores. En algunos casos, además del cifrado de canal que proporciona TLS, puede ser necesario aplicar cifrado adicional a nivel de la carga útil (payload) para proteger datos sensibles de manera más granular [34].

===== Ventajas

* Garantiza confidencialidad de los datos transmitidos mediante cifrado de canal.  
* Asegura la integridad y autenticidad de los mensajes, previniendo modificaciones y suplantación de identidad.  
* Protege contra ataques de intermediario (*MITM*).  
* Amplia compatibilidad con protocolos web y de API modernos.  
* Puede implementarse con autenticación mutua (*mTLS*) en arquitecturas de microservicios para validar ambos extremos de la comunicación.

===== Desventajas

* Requiere configuración cuidadosa de versiones de protocolo y algoritmos criptográficos.  
* Puede generar sobrecarga en términos de rendimiento, especialmente con cifrado fuerte o en entornos de alto tráfico.  
* La gestión de certificados y autoridades de certificación (CAs) añade complejidad administrativa.  
* Implementaciones incorrectas o uso de versiones obsoletas pueden introducir vulnerabilidades.


==== PASETO

El estándar Tokens de seguridad independientes de la plataforma (Platform-Agnostic Security Tokens, PASETO) surge como una alternativa moderna y más segura a JSON Web Tokens dentro de los esquemas de autenticación basados en tokens. PASETO fue diseñado para evitar los errores comunes y vulnerabilidades derivados del uso de Firma y cifrado de objetos JSON (JSON Object Signing and Encryption, JOSE), ofreciendo un formato más predecible, seguro y menos propenso a configuraciones inseguras [3].

A diferencia de JWT, que permite al desarrollador seleccionar entre una amplia variedad de algoritmos criptográficos, PASETO restringe esta elección y define un conjunto fijo de algoritmos por versión. La versión 1 utiliza algoritmos ampliamente adoptados como AES y RSA, mientras que la versión 2 emplea algoritmos modernos y más robustos, como Ed25519 para la firma digital y XChaCha20-Poly1305 para el cifrado autenticado. Este diseño elimina las posibilidades de que un atacante explote configuraciones débiles o confusas, incrementando la fiabilidad criptográfica del token [3].

Asimismo, PASETO admite tanto cifrado simétrico autenticado como firma con clave pública, cubriendo los mismos casos de uso que JWT, pero con una arquitectura más estricta y segura. Los algoritmos y bibliotecas empleados son conocidos únicamente por el servidor emisor del token, lo que dificulta los intentos de falsificación o manipulación. Además, cada versión del protocolo establece su propio conjunto de reglas y algoritmos, promoviendo la interoperabilidad y la previsibilidad en la implementación [36].  

En cuanto al desempeño, estudios comparativos han demostrado que JWT presenta una mejor eficiencia en tiempo de generación y tamaño de token; sin embargo, PASETO ofrece una resistencia significativamente superior frente a vulnerabilidades críticas. Según [36] las pruebas de seguridad realizadas evidenciaron que JWT es susceptible a ataques como Autenticación de usuarios deficiente (Broken User Authentication) y explotación de encabezados, mientras que PASETO mostró solidez ante las principales vulnerabilidades documentadas en los 10 principales riesgos de seguridad en APIs según OWASP [77].

===== Ventajas

* Su diseño prioriza la seguridad desde la definición de sus algoritmos y versiones.  
* Define algoritmos criptográficos fijos por versión, eliminando opciones inseguras.  
* Resistente frente a vulnerabilidades comunes en JWT (por ejemplo, manipulación del encabezado de algoritmo).  
* Ofrece autenticación basada en cifrado simétrico o en firma asimétrica.  
* Proporciona mayor previsibilidad y control criptográfico.  

===== Desventajas

* Menor rendimiento en comparación con JWT en la generación y transferencia de tokens.  
* Tamaño de token superior, lo que puede impactar en entornos con restricciones de ancho de banda.  
* Adopción limitada y menor disponibilidad de bibliotecas en comparación con JWT.  

[TIP]
====
PASETO representa una evolución hacia mecanismos de autenticación más seguros en APIs RESTful. Si bien su rendimiento es inferior, su diseño restringido y predecible lo convierte en una opción recomendable para sistemas que priorizan la seguridad sobre la eficiencia, especialmente en el manejo de datos sensibles o en arquitecturas distribuidas.
====

==== _Cross-Origin Resource Sharing_ (CORS)

_Cross-Origin Resource Sharing_ es un estándar que permite que aplicaciones web realicen solicitudes a APIs alojadas en dominios distintos al de la aplicación cliente. Este mecanismo surge como extensión controlada de la política del mismo origen (Same-Origin Policy), la cual bloquea solicitudes entre dominios diferentes para proteger contra ataques como Falsificación de solicitudes entre sitios (Cross-Site Request Forgery, CSRF) [37].   

La política del mismo origen considera que dos recursos comparten origen únicamente si coinciden en esquema (HTTP o HTTPS), dominio y puerto. Por ejemplo:

* `http://tienda.com/home` y `http://tienda.com/assets/style.css` tienen el mismo origen.  
* `https://tienda.com` no comparte origen con `http://tienda.com` debido a la diferencia de esquema.  
* `http://api.tienda.com` no comparte origen con `http://tienda.com` por ser un subdominio distinto.  
* `http://tienda.com:8080` no comparte origen con `http://tienda.com` porque usan puertos diferentes.  

CORS funciona mediante encabezados HTTP especiales que el servidor devuelve para indicar qué orígenes están autorizados, qué métodos HTTP se permiten y si se pueden enviar credenciales (cookies o cabeceras de autorización). En algunos casos, el navegador realiza primero una solicitud preliminar (preflight request) usando el método OPTIONS para verificar que la solicitud real está permitida. Si el servidor responde con los encabezados correctos, se ejecuta la solicitud principal.  

Este estándar permite configurar políticas de CORS a nivel global para toda la aplicación o de manera selectiva por el _endpoint_. Las políticas pueden definir qué dominios, métodos y cabeceras están permitidos, manteniendo la seguridad de la política del mismo origen al tiempo que habilitan la interoperabilidad entre aplicaciones y servicios en distintos dominios.  

===== Ventajas

* Habilita de forma controlada la comunicación entre dominios distintos.  
* Mantiene la protección de la política del mismo origen.  
* Permite configurar políticas específicas por dominio, método o endpoint.  

===== Desventajas

* Configuraciones inadecuadas pueden exponer la API a riesgos de seguridad.  
* Requiere comprender correctamente los encabezados y el flujo de CORS.  
* Puede añadir complejidad en la configuración de aplicaciones distribuidas.  

[TIP]
====
Es recomendable habilitar CORS únicamente cuando sea necesario, configurando políticas específicas y evitando permitir cualquier origen de manera global. Por ejemplo, solo permitir que `https://app.tienda.com` acceda a `http://api.tienda.com`.
====

==== Implementación de CORS en Python

A continuación se muestra cómo habilitar CORS en un API REST desarrollada con FastAPI:

[source,python]
----
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="Tienda API")

# Lista de dominios permitidos para acceder a la API
origins = [
    "https://app.tienda.com",
    "https://admin.tienda.com"
]

# Agregar el middleware de CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # solo los dominios especificados
    allow_credentials=True,  # permite enviar cookies o cabeceras de autorización
    allow_methods=["GET", "POST", "PUT", "DELETE"],  # métodos HTTP permitidos
    allow_headers=["Authorization", "Content-Type"],  # cabeceras permitidas
)
----

[TIP]
====
Evita habilitar CORS de forma global con `allow_origins=["*"]` en producción, ya que esto permite que cualquier dominio haga solicitudes a tu API, incrementando el riesgo de ataques.
====

==== ISO/IEC 27001: _Information Security Management_

ISO/IEC 27001 es un estándar internacionalmente reconocido para la gestión de la seguridad de la información. Proporciona un enfoque sistemático para administrar información sensible de la organización, garantizando que se mantenga segura. Esto incluye desde datos financieros, propiedad intelectual y detalles de empleados hasta información confiada por terceros [38].

El estándar establece la base para un _*Information Security Management System*_, exigiendo que la organización diseñe e implemente un conjunto coherente y completo de controles de seguridad de la información. Los controles no son prescriptivos, lo que permite a cada organización adaptarlos según sus necesidades y contexto. Entre los aspectos cubiertos se incluyen evaluación de riesgos, políticas de seguridad, gestión de activos, control de accesos y seguridad física y ambiental [39].

ISO/IEC 27001 puede aplicarse a cualquier organización, independientemente de su tamaño o industria, aunque resulta especialmente relevante en sectores que manejan información altamente sensible, como instituciones financieras. Su implementación proporciona un marco estructurado para proteger la información, reducir riesgos y demostrar un compromiso con las mejores prácticas de seguridad.

===== Beneficios de aplicar ISO/IEC 27001 en APIs

* **Gestión integral de la seguridad:** Permite establecer un marco consistente para proteger las APIs y la información que manejan [39].  
* **Flexibilidad:** Los controles pueden adaptarse a la complejidad de la organización y a las particularidades de sus servicios API [38].  
* **Reducción de riesgos:** Al incluir evaluaciones periódicas de riesgo y controles de seguridad, se disminuye la probabilidad de incidentes de seguridad [39].  
* **Mejora continua:** El estándar promueve la revisión constante y la actualización de medidas de seguridad, manteniendo las APIs seguras frente a nuevas amenazas [38].  
* **Confianza y reputación:** Aplicar ISO/IEC 27001 demuestra a clientes y socios un enfoque profesional y estructurado en la protección de datos [39].  

[TIP]
====
Al implementar APIs seguras dentro de un marco ISO/IEC 27001, las organizaciones no solo protegen la información, sino que también facilitan la interoperabilidad segura y el cumplimiento normativo, fortaleciendo la confianza de usuarios y socios comerciales.
====
==== NIST SP 800-228: Directrices para la protección de APIs en sistemas cloud-native

El NIST Special Publication 800-228 (_Guidelines for API Protection for Cloud-Native Systems_) establece lineamientos específicos para la protección y aseguramiento de APIs en entornos empresariales modernos. 
Este estándar reconoce que las APIs son el medio principal de comunicación e integración entre sistemas en arquitecturas nativas de la nube, por lo que su seguridad resulta esencial para la postura de seguridad general de las organizaciones [40].

El documento propone un modelo de protección integral del ciclo de vida de las APIs, basado en los principios de DevSecOps y el paradigma _Zero Trust_, considerando controles tanto previos a la ejecución (pre-runtime) como durante la ejecución (runtime). 
Estos controles se clasifican en básicos y avanzados, lo que permite su adopción de forma incremental y basada en el riesgo, de acuerdo con la madurez de la organización.

Entre sus principales aportaciones destacan:

* Identificación de factores de riesgo y vulnerabilidades que pueden introducirse durante el desarrollo o despliegue de APIs.
* Controles y medidas de protección recomendadas que abarcan desde la fase de diseño hasta la ejecución de peticiones.
* Patrones de implementación con análisis de ventajas y desventajas, que orientan a los profesionales de seguridad en la selección de enfoques adecuados a su ecosistema tecnológico.
* Clasificación de APIs y su relación con las fases del ciclo DevSecOps, facilitando la integración de la seguridad como parte del desarrollo continuo.

Este estándar resulta relevante para las guías de diseño seguro de APIs REST, ya que ofrece un marco actualizado para mitigar vulnerabilidades desde la concepción y el diseño, reforzando la seguridad mediante controles expresados en términos de recursos (nombres) y operaciones (verbos), en coherencia con los principios REST.

==== Regulaciones de protección de datos y privacidad

Además de los estándares técnicos y normativos como ISO/IEC 27001 y NIST SP 800-228, existen marcos legales que complementan la seguridad de las APIs desde la perspectiva de la protección de datos personales y la privacidad. Estas regulaciones buscan garantizar que las organizaciones gestionen la información sensible de manera responsable, transparente y conforme a los derechos de los individuos.  

Entre las más relevantes se encuentran el Reglamento General de Protección de Datos (GDPR) en la Unión Europea, la California Consumer Privacy Act (CCPA) en Estados Unidos y la Personal Information Protection and Electronic Documents Act (PIPEDA) en Canadá. Todas ellas establecen obligaciones como obtener consentimiento para el tratamiento de datos, aplicar medidas técnicas de seguridad y permitir a los usuarios ejercer derechos sobre su información [39].

===== GDPR: Reglamento General de Protección de Datos (Unión Europea)

El Reglamento General de Protección de Datos (GDPR) representa el marco más influyente en materia de privacidad a nivel mundial. Su objetivo es proteger los datos personales de los ciudadanos y residentes europeos, fortaleciendo sus derechos y unificando las regulaciones entre los Estados miembros. [39]

El GDPR establece principios fundamentales de transparencia, responsabilidad y minimización de datos, los cuales pueden integrarse de forma natural en el diseño y operación de APIs REST seguras.  
Entre sus disposiciones más destacadas se incluyen:

* **Derechos de los interesados:** acceso, rectificación, eliminación (*derecho al olvido*) y portabilidad de datos personales.  
* **Consentimiento informado:** las organizaciones deben obtener autorización clara y explícita antes de procesar datos personales.  
* **Seguridad y confidencialidad:** uso obligatorio de controles técnicos como cifrado, autenticación, control de accesos, auditorías y gestión de incidentes.  
* **Minimización de datos:** procesar solo la información estrictamente necesaria para los fines declarados.  
* **Responsabilidad y documentación:** mantener registros detallados de las actividades de tratamiento y, cuando corresponda, designar un Delegado de Protección de Datos (DPO).

[WARNING]
====

El incumplimiento del GDPR puede acarrear sanciones severas, de hasta 20 millones de euros o el 4 % de la facturación anual global, además de un daño reputacional considerable.  

Por ello, el cumplimiento de esta regulación se considera una práctica esencial en el diseño y operación de APIs que gestionen información personal o sensible.
====

===== Consideraciones del GDPR aplicadas a la seguridad de APIs

Para alinear el diseño de APIs REST con los principios del GDPR, se recomiendan las siguientes buenas prácticas:

* **Minimización de datos:** limitar los datos transmitidos a lo estrictamente necesario.  
* **Gestión del consentimiento:** implementar mecanismos para obtener, registrar y revocar el consentimiento de los usuarios.  
* **Cifrado:** proteger la información personal mediante cifrado de extremo a extremo en tránsito y en reposo.  
* **Control de acceso:** restringir el uso de las APIs únicamente a usuarios o sistemas autenticados y autorizados.  
* **Derechos de los interesados:** habilitar puntos de entrada (endpoints) que permitan ejercer derechos como acceso, rectificación o eliminación de datos.  
* **Evaluaciones de impacto (DPIA):** analizar riesgos asociados al tratamiento de datos personales mediante APIs.  
* **Acuerdos de procesamiento de datos:** definir responsabilidades y obligaciones contractuales entre las partes que procesan datos.  
* **Notificación de brechas:** establecer procedimientos para detectar, registrar y notificar incidentes de seguridad.  
* **Transferencias internacionales:** garantizar que los datos transferidos fuera del Espacio Económico Europeo cuenten con mecanismos adecuados de protección.  
* **Gestión de proveedores:** verificar que los terceros o servicios de API cumplan también con los requisitos del GDPR.  
* **Transparencia y documentación:** mantener información clara sobre el uso y tratamiento de los datos a través de las APIs.  
* **Capacitación y sensibilización:** formar a los equipos de desarrollo y operación sobre los principios de privacidad y protección de datos.

[TIP]
====
La integración de estas consideraciones en el ciclo de vida de las APIs refuerza la confianza de los usuarios y contribuye al cumplimiento normativo, alineándose con el enfoque de seguridad desde el diseño.
====

==== Regulaciones legales relacionadas con la seguridad en APIs

Además de los estándares técnicos, existen regulaciones legales que establecen requisitos específicos para la protección de datos y la ciberseguridad. Estas regulaciones suelen exigir la implementación de medidas que prevengan el acceso no autorizado, la divulgación indebida o el uso inapropiado de la información.  

Entre las más relevantes se encuentran la Ley de Portabilidad y Responsabilidad del Seguro de Salud (Health Insurance Portability and Accountability Act, HIPAA) en Estados Unidos y la Ley de Ciberseguridad (Cybersecurity Law) de la República Popular de China, que obligan a las organizaciones a implementar controles de seguridad y reportar incidentes relacionados con la protección de datos y sistemas [41, 42].

===== _Health Insurance Portability and Accountability Act_

La HIPAA es una regulación estadounidense que establece estándares para la protección de la información médica sensible, conocida como Información de Salud Protegida (Protected Health Information, PHI). Su objetivo es garantizar la confidencialidad, integridad y disponibilidad de la PHI, al mismo tiempo que facilita la portabilidad del seguro médico y la eficiencia del sistema de salud [41].

Uno de los pilares de la HIPAA es la Regla de privacidad (Privacy Rule), que otorga a los pacientes derechos sobre su información médica, incluyendo el acceso, modificación y obtención de registros de uso. Por su parte, la Regla de seguridad (Security Rule) define salvaguardas administrativas, físicas y técnicas que las entidades deben aplicar para proteger la PHI electrónica (ePHI), tales como controles de acceso, cifrado, auditorías y planes de contingencia.

Asimismo, la HIPAA requiere que las entidades cubiertas establezcan acuerdos con sus asociados comerciales para asegurar el cumplimiento de las normas de privacidad y seguridad, siendo ambos responsables ante las autoridades reguladoras.

[WARNING]
====
El incumplimiento de la HIPAA puede derivar en sanciones económicas severas, además de planes obligatorios de acción correctiva supervisados por la Oficina de Derechos Civiles (Office for Civil Rights, OCR) del Departamento de Salud y Servicios Humanos de los Estados Unidos (U.S. Department of Health & Human Services, HHS)
====

===== Consideraciones de la HIPAA en el diseño de APIs

Al desarrollar o integrar APIs que manejen información médica o datos sensibles, deben observarse los siguientes principios para cumplir con la HIPAA:

* **Cifrado de datos:** Utilizar protocolos como TLS para proteger la transmisión de datos.  
* **Control de acceso:** Implementar mecanismos de autenticación y autorización (por ejemplo, OAuth 2.0).  
* **Registros de auditoría:** Mantener trazabilidad de accesos y transacciones realizadas mediante la API.  
* **Minimización de datos:** Limitar la transmisión y exposición de PHI únicamente a lo necesario.  
* **Comunicación segura:** Emplear canales protegidos para evitar interceptaciones o alteraciones.  
* **Verificación de autorización:** Comprobar permisos en cada punto de acceso (endpoint) antes de exponer recursos.  
* **Almacenamiento seguro:** Proteger los datos almacenados mediante cifrado y controles de acceso.  
* **Documentación de cumplimiento:** Registrar políticas, controles y medidas de seguridad adoptadas.  

[TIP]
====
La HIPAA es especialmente relevante en APIs del sector salud o aquellas que gestionen información personal sensible.  
Aunque su aplicación es obligatoria solo en Estados Unidos, sus principios pueden servir como guía de buenas prácticas internacionales.
====

=== Modelado de amenazas

El modelado de amenazas es un enfoque de seguridad proactivo y estructurado que se utiliza para identificar, evaluar y mitigar posibles riesgos dentro de la arquitectura de un sistema antes de que puedan ser explotados. Permite visualizar cómo un atacante podría aprovechar vulnerabilidades mediante la identificación de activos críticos, como datos sensibles; la evaluación de vectores de ataque; el análisis de posibles actores de amenaza; y la definición de estrategias de mitigación para cada riesgo.

Como práctica clave, garantiza que las consideraciones de seguridad se integren desde las etapas iniciales de diseño hasta la implementación y operación, en consonancia con los principios de desplazamiento a la izquierda (Shift Left) y seguridad desde el diseño (Secure by Design) Al anticipar vulnerabilidades de forma temprana, ayuda a tomar decisiones de diseño informadas, reducir costos de retrabajo y fomentar la creación de sistemas inherentemente seguros.

==== Importancia del modelado de amenazas

El Manifiesto de Modelado de Amenazas señala que este proceso permite reconocer lo que puede salir mal en un sistema. Además, ayuda a identificar problemas de diseño e implementación que requieren mitigación, ya sea desde el inicio o a lo largo de la vida útil del sistema. 

El resultado de este análisis —las amenazas— sirve como insumo clave para guiar las decisiones en las fases posteriores de diseño, desarrollo, pruebas y mantenimiento [43].

==== Propósito del modelado de amenazas

El principal objetivo del modelado de amenazas es proporcionar un marco sistemático que permita identificar, comprender, priorizar y mitigar posibles riesgos [44].

A través de este enfoque, las organizaciones pueden anticipar cómo los atacantes podrían explotar debilidades, entender las motivaciones y capacidades de los actores de amenaza, y establecer estrategias de defensa adecuadas [44]

* **Identificar:** Descubrir posibles amenazas, vulnerabilidades y debilidades en el sistema o aplicación [44].  
* **Comprender:** Analizar cómo estas amenazas pueden afectar el sistema, incluyendo las motivaciones, capacidades y posibles vectores de ataque [44].  
* **Priorizar:** Evaluar y clasificar las amenazas identificadas según su gravedad, probabilidad de ocurrencia e impacto potencial [44].  
* **Mitigar:** Desarrollar e implementar estrategias para reducir o eliminar los riesgos detectados, lo cual puede implicar rediseñar componentes, fortalecer defensas o establecer mecanismos de monitoreo y respuesta [44].

==== Cuándo realizar el modelado de amenazas

El modelado de amenazas debe integrarse como parte del ciclo de vida del desarrollo de software (SDLC), preferentemente desde las fases tempranas de diseño o definición de requisitos [44].

Esto permite detectar vulnerabilidades potenciales antes de que se vuelvan costosas o difíciles de corregir.  

Sin embargo, también se recomienda revisarlo y actualizarlo cuando se presenten cambios significativos en la arquitectura, se descubran nuevas amenazas o el sistema migre a una infraestructura diferente [44].

==== Elementos fundamentales del modelado de amenazas

El proceso de modelado de amenazas abarca varios componentes esenciales [44]:

* **Activos:** Representan los elementos valiosos que requieren protección, como datos sensibles, propiedad intelectual, funcionalidades críticas o la privacidad del usuario.  
* **Actores de amenaza:** Son individuos o grupos que podrían intentar explotar vulnerabilidades del sistema, como cibercriminales, hacktivistas, actores estatales o amenazas internas.  
* **Amenazas:** Acciones o eventos potencialmente negativos que podrían comprometer un activo, como brechas de datos, ataques DoS o campañas de suplantación de identidad (phishing).  
* **Vulnerabilidades:** Debilidades o fallos en el diseño, implementación o configuración del sistema que pueden ser explotados.  
* **Vectores de ataque:** Rutas o métodos empleados por un atacante para obtener acceso o explotar una vulnerabilidad, como _phishing_, puertos abiertos o bibliotecas comprometidas.  
* **Contramedidas:** Controles o mecanismos implementados para mitigar o eliminar las amenazas identificadas, que pueden ser técnicos (cifrado, autenticación), procedimentales (políticas de seguridad, capacitación) o físicos (acceso restringido a servidores).

[TIP]
====
El modelado de amenazas debe verse como un proceso iterativo y vivo: se adapta con el sistema, sus usuarios y su entorno.  
Actualizarlo regularmente es una práctica esencial para mantener la resiliencia y la seguridad de los sistemas frente a nuevas amenazas [44].
====

==== Proceso de modelado de amenazas
De igual forma, OWASP menciona que el proceso de modelado de amenazas se puede descomponer en cuatro pasos de alto nivel.

Cada paso se documenta a medida que se lleva a cabo. Esto nos da como resultado un documento, el cual es el modelado de amenazas para la aplicación.  

Se debe tener en cuenta que el trabajo de modelado de amenazas y el trabajo de crear documentos de modelado de amenazas son distintos [45].

Los cuatro pasos propuestos por OWASP son:

1. Paso 1: Alcance de su trabajo.  
2. Paso 2: Determinar las amenazas.  
3. Paso 3: Determinar las contramedidas y la mitigación.  
4. Paso 4: Evaluar su trabajo.  

===== Paso 1: Alcance de su trabajo

A este primer paso también se le conoce como “descomponer la aplicación”, el cual es un enfoque que se utiliza para realizar una revisión del modelo de amenazas o de la arquitectura. Este paso se refiere a entender la manera en la que funciona el sistema.  
Para ello, se deben seguir los siguientes puntos:

* Dibujar diagramas.  
* Identificar puntos de entrada.  
* Identificar activos.  
* Identificar los niveles de confianza.  
* Leer o crear historias de usuario.

Esta descomposición se lleva a cabo realizando *diagramas de flujo de datos (DFD)* con la información obtenida a partir de los pasos anteriores. Estos diagramas muestran las diferentes rutas a través del sistema, resaltando los límites de privilegios o confianzas.

===== Paso 2: Determinar las amenazas

Este paso es una actividad de investigación para encontrar las principales amenazas que pueden dañar el sistema.  
Para poder identificarlas es fundamental utilizar una metodología de categorización, como STRIDE, PASTA, VAST o SQUARE [44, 45].  

====== Metodología STRIDE

La metodología **STRIDE** fue desarrollada por Microsoft y es una de las más utilizadas para modelar amenazas.  
Su nombre proviene del acrónimo de seis categorías de amenazas, que ayudan a los diseñadores a pensar como un atacante e identificar debilidades específicas [44]:


|===
| Categoría | Descripción | Ejemplo de ataque | Contramedida típica

| _**S**poofing_
| Ocurre cuando un atacante se hace pasar por alguien o algo que no es para obtener acceso no autorizado a los recursos.
| Robo de credenciales de inicio de sesión para suplantar a un usuario legítimo o la creación de un sitio web falso que engaña a las víctimas para que revelen información confidencial.
| Autenticación fuerte, MFA, validación de identidad.

| _**T**ampering_
| Modificación no autorizada de datos, ya sea en tránsito o en reposo.
| Interceptar y modificar las comunicaciones entre sistemas o alterar datos almacenados.
| Cifrado de datos, uso de hash en archivos y datos, controles de acceso robustos para garantizar la integridad de los datos.

| _**R**epudiation_
| Un usuario niega haber realizado una acción y el sistema carece de la capacidad de demostrar lo contrario.
| Un usuario niega haber realizado una transacción financiera.
| Auditoría, bitácoras de eventos, firmas digitales y uso de frameworks de logging.

| _**I**nformation Disclosure_
| Fuga de datos confidenciales hacia partes no autorizadas.
| Puede manifestarse cuando los atacantes espían las comunicaciones de la red, acceden a archivos no protegidos o aprovechan vulnerabilidades para obtener acceso no autorizado a los datos.
| Cifrado de datos, control de acceso, procesos de clasificación y manejo de datos.

| _**D**enial of Service_
| Su objetivo es hacer que un sistema o servicio no esté disponible para sus usuarios previstos.
| Saturación con tráfico excesivo o explotación de vulnerabilidades para provocar su caída.
| Limitación de tasa (rate limiting), uso de WAF, diseñar sistemas con capacidad de redundancia y recuperación ante fallos.

| _**E**levation of Privilege_
| Un atacante obtiene permisos superiores a los que debería tener, lo que le permite realizar acciones no autorizadas.
| Usuario aprovecha una vulnerabilidad para obtener privilegios administrativos podría tener acceso sin restricciones a datos confidenciales o funciones críticas del sistema.
| Principio del mínimo privilegio, auditorías periodicas de privilegios y corrección de vulnerabilidades.
|===

====== Ventajas de STRIDE

Una de las ventajas más significativas del modelo STRIDE es su simplicidad y versatilidad, lo que lo hace aplicable a una amplia variedad de sistemas y servicios. Los equipos de seguridad y los desarrolladores pueden utilizar STRIDE para realizar análisis de amenazas de manera sistemática durante la fase de diseño, ayudándoles a comprender y anticipar posibles riesgos.  
Al categorizar las amenazas mediante STRIDE, los arquitectos de seguridad pueden asegurar una evaluación integral de las preocupaciones de seguridad, abordando desde los mecanismos de autenticación hasta la integridad y disponibilidad de los datos [44].

====== Uso de STRIDE en el modelado de amenazas

En la práctica, el modelado de amenazas utilizando STRIDE normalmente comienza con la comprensión de la arquitectura del sistema que se está analizando.  
Los profesionales de seguridad elaboran diagramas de flujo de datos (DFD) para visualizar cómo fluye la información a través del sistema, identificando componentes clave como almacenes de datos, procesos y canales de comunicación.  
Cada elemento del DFD se evalúa luego empleando el modelo STRIDE para identificar amenazas potenciales.  

[TIP]
====
El uso del modelo STRIDE permite a los equipos de seguridad comprender y anticipar los riesgos de manera estructurada.  
Su aplicación facilita una evaluación holística de los problemas de seguridad y fomenta la integración temprana de controles de protección durante la fase de diseño [44].
====

===== Paso 3: Determinar las contramedidas y la mitigación

Después de haber identificado las amenazas, se deben definir las contramedidas adecuadas para mitigar los riesgos y evitar que el sistema se vea comprometido.  

Una vulnerabilidad puede mitigarse mediante la implementación de una contramedida. Dichas contramedidas se pueden identificar mediante listas de asignación de amenazas-contramedidas.  
Los factores que se incluyen en esta selección son la probabilidad de ataque, el daño potencial y el costo o complejidad de la mitigación [45].  

Las opciones para abordar el riesgo incluyen:

* **Aceptar:** el impacto es aceptable.  
* **Eliminar:** se eliminan los componentes que originan la vulnerabilidad.  
* **Mitigar:** se agregan controles o comprobaciones que reduzcan el impacto.  
* **Transferir:** el riesgo se transfiere a un tercero (aseguradora, cliente, etc.).

===== Paso 4: Evaluar su trabajo

Al concluir cualquier proyecto o tarea, es crucial hacerse una pregunta fundamental: ¿hicimos un trabajo lo suficientemente bueno?  
Este paso implica realizar una actividad retrospectiva, analizando de manera detallada y honesta la calidad de los resultados y la viabilidad de las soluciones implementadas.  
Este proceso de revisión fomenta la mejora continua en la práctica del modelado de amenazas [45].

==== Ejemplo práctico

A continuación, se presenta un ejemplo simplificado de modelado de amenazas utilizando la metodología STRIDE para una API REST del área de la salud que maneja datos de pacientes, permite el acceso a historiales médicos y facilita la programación de citas médicas.

Existen diversas herramientas que pueden ayudar a documentar el modelado de amenazas, como las siguientes:

* OWASP Threat Dragon: Aplicación gratuita, de código abierto y multiplataforma para crear modelos de amenazas basados en diagramas de flujo de datos (DFD). La herramienta se encuentra disponible para su uso a través del siguiente enlace: https://www.threatdragon.com/#/

* Microsoft Threat Modeling Tool: Herramienta oficial del Microsoft Security Development Lifecycle (SDL) diseñada para ayudar a arquitectos y desarrolladores a identificar y mitigar posibles problemas de seguridad desde las primeras etapas del diseño, cuando aún son fáciles y económicos de resolver. A continuación, se presenta un enlace a una guía para el uso de la herramienta. https://learn.microsoft.com/en-us/azure/security/develop/threat-modeling-tool 

* IriusRisk: Plataforma abierta de modelado de amenazas que automatiza y apoya la creación de modelos de amenaza desde la etapa de diseño. Incluye recomendaciones sobre cómo abordar los riesgos e integra la gestión de riesgos de seguridad durante todo el ciclo de vida del desarrollo de software (SDLC). La herramienta se encuentra disponible para su uso a través del siguiente enlace: https://iriusrisk.com/

* ThreatModeler: Plataforma continua de modelado de amenazas que automatiza la identificación de riesgos desde la etapa de diseño, integrando la seguridad en el ciclo de desarrollo. Permite generar modelos automáticamente, gestionar requisitos de mitigación e integrarse con herramientas como Jira o Azure DevOps. La herramienta se encuentra disponible para su uso a través del siguiente enlace: https://threatmodeler.com/

En este caso, se utilizará OWASP Threat Dragon para ilustrar el proceso de modelado de amenazas debido a que es una herramienta gratuita y fácil de usar.

===== Paso 1 — Alcance del trabajo

En esta etapa se define el alcance del sistema y se descompone la aplicación para entender su funcionamiento general.  

Comunmente el documento de modelado de amenazas contiene los siguientes elementos:

* Nombre del sistema: Nombre del sistema o aplicación que se está examinando.
* Versión: Versión del sistema o aplicación.
* Descripción: Breve descripción del sistema, explicando de manera general.
* Propietario del documento: Dueño o responsable del documento de modelado de amenazas.
* Participantes: Nombres de las personas que participaron en el modelado de amenazas.
* Revisor: Nombre de la persona que revisó el documento.

En nuestro ejemplo, se tiene la siguiente información:

* Nombre del sistema: _**HealthAPI**_

* Versión: 1.0

* Descripción: API REST para la gestión de datos de pacientes, historiales médicos y citas en una clínica.

* Propietario del documento: Eduardo Carrera Colorado

* Participantes: Aneth Michelle Tamariz Moreno

* Revisor: Juan Carlos Pérez Arriaga

====== Dependencias externas

Las dependencias externas son elementos ajenos al código de la aplicación que pueden representar una amenaza para ella. Estos elementos suelen estar bajo el control de la organización, aunque posiblemente no bajo el control directo del equipo de desarrollo.

Un aspecto a considerar cuando se analizan las dependencias externas es el entorno de producción y sus requisitos. Por ejemplo, si se espera que la aplicación se ejecute en un servidor y que esté detrás de un corta fuegos(firewall), esta información debe documentarse en esta sección [45].

Las dependencias externas deben documentarse de la siguiente manera:

* Identficador (ID): Un identificador único asignado a la dependencia externa.

* Descripción: Una descripción textual de la dependencia externa.

En nuestro ejemplo, se tienen las siguientes dependencias externas:

.Dependencias Externas (Ejemplo)
[cols="1,4", options="header"]
|===
| ID | Descripción

| DE-1 | La API REST del sistema de salud se ejecutará en un servidor Linux con Nginx. El servidor será reforzado conforme a la línea base de seguridad de la organización, incluyendo la instalación de los parches más recientes del sistema operativo y de seguridad de aplicaciones.
| DE-2 | El servidor de base de datos usará PostgreSQL y se ejecutará en una instancia Linux separada. Será reforzado siguiendo el estándar de seguridad de la organización e incluirá actualizaciones periódicas y monitoreo de la actividad de la base de datos.
| DE-3 | La comunicación entre el servidor de la API y el servidor de base de datos se realizará a través de una red privada, aislada de Internet pública.
| DE-4 | La API dependerá de un proveedor externo de autenticación (OAuth 2.0) para la gestión segura del acceso de usuarios. La integración se realizará mediante HTTPS y autenticación basada en tokens.
| DE-5 | El servidor web que aloja la puerta de enlace (API Gateway) se encuentra detrás de un _firewall_, y toda comunicación externa está restringida únicamente a conexiones TLS (HTTPS).
|===

====== Puntos de entrada

Los puntos de entrada definen las interfaces a través de las cuales los usuarios o sistemas externos interactúan con la aplicación. Estos puntos son críticos, ya que representan las vías por las que un atacante podría intentar acceder o explotar el sistema.

Los puntos de entrada muestran dónde se ingresan los datos al sistema, por ejemplo, los campos de entrada en un formulario web, los endpoints de una API REST o las interfaces de usuario.

Los puntos de entrada deben documentarse de la siguiente manera:

* ID: Un identificador único asignado al punto de entrada. Este se utilizará para hacer referencia cruzada entre el punto de entrada y cualquier amenaza o vulnerabilidad identificada. En el caso de puntos de entrada organizados en capas, se debe usar una notación mayor.menor.

* Nombre: Un nombre descriptivo que identifique el punto de entrada y su propósito.

* Descripción: Una descripción textual que detalle la interacción o el procesamiento que ocurre en el punto de entrada.

* Niveles de confianza: El nivel de acceso requerido en el punto de entrada. Estos se referenciarán con los niveles de confianza definidos más adelante en el documento.

En nuestro ejemplo, se tienen los siguientes puntos de entrada:

.Puntos de Entrada (Ejemplo)
[cols="1,1,3,1", options="header"]
|===
| ID | Nombre | Descripción | Nivel de confianza

| PE-1 | Endpoint de autenticación (`/auth/login`) | Punto de entrada donde los usuarios envían sus credenciales (correo electrónico y contraseña) para autenticarse mediante el proveedor externo OAuth 2.0. Los datos son enviados mediante una conexión HTTPS segura y procesados por el servidor de autenticación. | Público autenticado

| PE-2 | Endpoint de registro de paciente (`/patients/register`) | Permite a personal autorizado registrar nuevos pacientes en el sistema de salud. Requiere token de autenticación válido emitido por el servicio OAuth 2.0. | Personal médico

| PE-3 | Endpoint de consulta de información del paciente (`/patients/{id}`) | Proporciona acceso a la información clínica de un paciente. Solo puede ser accedido por usuarios autenticados con rol autorizado. | Personal médico

| PE-4 | Endpoint de actualización de expediente clínico (`/records/update`) | Permite actualizar la información médica de un paciente. Requiere autenticación y privilegios elevados (médico o administrador del sistema). | Alta confianza

| PE-5 | Endpoint de monitoreo del sistema (`/health/status`) | Permite verificar el estado operativo de la API REST (disponibilidad y estado de servicios). Es utilizado por el sistema de monitoreo interno y no expuesto al público. | Interno

| PE-6 | Interfaz administrativa web | Panel de control accesible únicamente por administradores del sistema para la gestión de usuarios, roles y configuraciones. Protegido mediante autenticación multifactor. | Alta confianza
|===  

====== Puntos de salida

Mientras que los puntos de entrads muestran dónde se ingresan los datos al sistema, los puntos de salida indican dónde los datos salen del sistema. Estos puntos son igualmente críticos, ya que al momento de atacar el lado del cliente, las vulnerabilidades de secuencias de comandos entre sitios (Cross-Site Scripting, XSS) y las de divulgación de información requieren un punto de salida para que el ataque se complete.

En muchos casos, las amenazas habilitadas por los puntos de salida están relacionadas con las amenazas de los correspondientes puntos de entrada. En el ejemplo del inicio de sesión, los mensajes de error devueltos al usuario a través del punto de salida (la página de inicio de sesión) podrían permitir ataques en el punto de entrada, como recolección de cuentas (por ejemplo, “nombre de usuario no encontrado”).

Al documentar los puntos de salida se deben considerar los mismos elementos que en los puntos de entrada, tal como se muestra en el siguiente ejemplo:

.Puntos de Salida (Ejemplo)
[cols="1,1,3,1", options="header"]
|===
| ID | Nombre | Descripción | Nivel de confianza

| PS-1 | Respuesta del endpoint `/patients/{id}` | Salida que devuelve la información clínica del paciente (JSON) al cliente. Contiene datos sensibles —por ejemplo, diagnóstico, medicamentos— por lo que su formato, encoding y encabezados de respuesta deben asegurar confidencialidad e integridad. Riesgos: divulgación de información, falta de encriptado en tránsito, exposición por errores en serialización. | Alta confianza

| PS-2 | Respuesta del endpoint `/records/update` | Mensajes de confirmación y/o datos devueltos tras actualizar un expediente clínico. Debe evitarse la exposición innecesaria de datos y proporcionar mensajes genéricos en caso de error para no facilitar recolección de cuentas o inyección. | Alta confianza

| PS-3 | Mensajes de error en `/auth/login` | Salidas que muestran errores de autenticación al usuario (por ejemplo: "usuario no encontrado", "contraseña incorrecta"). Mensajes demasiado verbales pueden facilitar ataques de enumeración de cuentas o revelar detalles de implementación. Riesgos: account harvesting, info leakage. | Público / No autenticado

| PS-4 | Registros del sistema (logs) | Salida interna donde se almacenan eventos (logs de acceso, errores, trazas). Si los logs contienen datos personales sin enmascarar, pueden provocar divulgación si se accede a ellos indebidamente. Deben definirse políticas de retención, acceso y enmascaramiento. | Interno

| PS-5 | Notificaciones externas (email/SMS) | Mensajes y payloads enviados a proveedores de correo o SMS para notificaciones de pacientes/usuarios (p. ej. citas, restablecimiento de contraseña). Riesgos: fuga de información a terceros, exposición por integraciones inseguras. | Proveedor externo

| PS-6 | Respuesta del endpoint `/health/status` | Información de estado del servicio devuelta a sistemas de monitoreo. Debe evitarse incluir datos sensibles o detalles de configuración que puedan ayudar a un atacante. | Interno / Monitorización
|===


====== Activos

Los activos pueden ser tanto físicos como abstractos. Suelen ser elementos o áreas de interes para un atacante.

Por ejemplo, un activo físico podría ser la lista de registros de pacientes, mientras que un activo abstracto podría ser la reputación de la organización. En ambos casos, los activos son valiosos y deben protegerse.

Los activos deben documentarse de la siguiente manera:

* ID: Se asigna un identificador único a cada activo. Este identificador se usa para hacer referencias cruzadas con las amenazas o vulnerabilidades identificadas.

* Nombre: Un nombre descriptivo que identifique claramente el activo.

* Descripción: Una descripción textual que explique qué es el activo y por qué necesita protección.

* Niveles de confianza: El nivel de acceso requerido para acceder al activo se documenta aquí. Estos se cruzarán con los niveles de confianza definidos en el siguiente paso.

En nuestro ejemplo, se tienen los siguientes activos:

.Activos del Sistema de Salud (Ejemplo)
[cols="1,1,3,1", options="header"]
|===
| ID | Nombre | Descripción | Niveles de confianza

| A-1 | Usuarios del Sistema | Activos relacionados con pacientes, médicos, enfermeros y administradores. |

| A-1.1 | Credenciales de Pacientes | Credenciales utilizadas por los pacientes para autenticarse en la API REST del sistema de salud. | (1) Paciente autenticado
(2) Médico autorizado
(3) Administrador del sistema

| A-1.2 | Credenciales de Personal Médico | Credenciales utilizadas por médicos y enfermeros para acceder a la API. | (2) Médico autorizado
(3) Administrador del sistema

| A-1.3 | Datos Personales de Pacientes | Información sensible como historial clínico, diagnósticos, tratamientos y datos de contacto. | (2) Médico autorizado
(3) Administrador del sistema
(4) Sistema de respaldo seguro

| A-2 | Sistema | Activos relacionados con la infraestructura y los servicios del sistema de salud. |

| A-2.1 | Disponibilidad de la API REST | La API debe estar disponible 24/7 para usuarios autorizados y personal médico. | (3) Administrador del sistema
(4) Servicio de monitoreo

| A-2.2 | Capacidad de ejecutar código en el servidor | Permite ejecutar código en el servidor de la API bajo usuario del servidor web. | (3) Administrador del sistema

| A-2.3 | Capacidad de ejecutar consultas SQL en la base de datos | Permite realizar select sobre la base de datos para acceder a información clínica. | (3) Administrador del sistema
(4) Usuario de lectura en BD

| A-2.4 | Capacidad de ejecutar SQL con permisos de lectura/escritura | Permite modificar y consultar cualquier información en la base de datos. | (3) Administrador del sistema
(5) Usuario de lectura/escritura en BD

| A-3 | API y Servicios | Activos relacionados con el funcionamiento de la API y la interacción de los usuarios. |

| A-3.1 | Sesión de Usuario | La sesión activa de un paciente, médico o administrador en la API. | (1) Paciente autenticado
(2) Médico autorizado
(3) Administrador del sistema

| A-3.2 | Acceso a la base de datos | Acceso al servidor de base de datos para administración y consulta de datos. | (3) Administrador del sistema

| A-3.3 | Capacidad de crear usuarios | Permite a administradores crear nuevos usuarios (pacientes, médicos, personal). | (3) Administrador del sistema

| A-3.4 | Acceso a registros de auditoría | Permite revisar eventos auditables del sistema: login, modificaciones de datos y acciones críticas. | (3) Administrador del sistema
|===


====== Niveles de confianza

Los niveles de confianza representan los derechos de acceso que la aplicación otorgará a entidades externas. Los niveles de confianza se referencian con los puntos de entrada y los activos. Esto nos permite definir los derechos o privilegios de acceso requeridos en cada punto de entrada, así como los necesarios para interactuar con cada activo.

Los niveles de confianza se documentan en el modelo de amenazas de la siguiente manera:

* ID: Se asigna un número único a cada nivel de confianza. Este se utiliza para hacer referencia cruzada con los puntos de entrada y los activos.

* Nombre: Un nombre descriptivo que permite identificar las entidades externas a las que se les ha otorgado este nivel de confianza.

* Descripción: Una descripción textual del nivel de confianza que detalla la entidad externa que ha recibido dicho nivel.

.Niveles de Confianza (Ejemplo)
[cols="1,1,3", options="header"]
|===
| ID | Nombre | Descripción

| NC-1 | Usuario Anónimo | Usuario que se conecta a la API REST pero no ha proporcionado credenciales válidas. Acceso limitado a endpoints públicos.  

| NC-2 | Paciente Autenticado | Paciente que ha iniciado sesión con credenciales válidas y puede acceder a sus propios datos clínicos y solicitudes autorizadas.  

| NC-3 | Usuario con Credenciales Inválidas | Usuario que intenta autenticarse con credenciales incorrectas. Riesgo potencial de ataques de fuerza bruta o enumeración de cuentas.  

| NC-4 | Personal Médico | Médicos y enfermeros autorizados que pueden acceder a datos de pacientes, actualizar expedientes y registrar procedimientos.  

| NC-5 | Administrador de Base de Datos | Administrador del servidor de base de datos con permisos de lectura/escritura sobre la base de datos de pacientes y registros clínicos.  

| NC-6 | Administrador del Sistema | Responsable de la configuración, mantenimiento y despliegue de la API REST y sus servicios asociados.  

| NC-7 | Proceso del Servidor Web | Usuario/proceso bajo el cual el servidor web ejecuta código y se autentica contra la base de datos.  

| NC-8 | Usuario de Lectura en BD | Cuenta de base de datos utilizada únicamente para consultas (SELECT) de información clínica.  

| NC-9 | Usuario de Lectura/Escritura en BD | Cuenta de base de datos utilizada para consultas y modificaciones (SELECT, INSERT, UPDATE) de datos clínicos y administrativos.  
|===


====== Diagramas de Flujo de Datos (DFD)

El modelado de amenazas de sistemas de software se ha realizado históricamente utilizando **diagramas de flujo de datos**. Los DFDs capturan los aspectos dinámicos del sistema, mostrando cómo la información fluye entre componentes. Son fáciles de entender y permiten identificar claramente cómo los datos se mueven a través del sistema, lo que facilita la detección de posibles vulnerabilidades y amenazas.

Los **DFDs permiten**:

* Comprender la aplicación mediante una representación visual de cómo se procesan los datos.
* Identificar componentes afectados a través de puntos críticos, como la entrada o salida de datos y su almacenamiento.
* Analizar el flujo de control dentro de los componentes.
* Decomponer la aplicación en subsistemas y subprocesos, desde un nivel alto hasta niveles más detallados, clarificando el alcance de la aplicación y los procesos específicos involucrados.

Los componentes principales de un DFD son:

* **Entidades externas**: Aplicaciones o servicios que no forman parte de nuestro sistema. En nuestro caso, esto sería la **aplicación móvil**.
* **Procesos**: Una aplicación o tarea dentro de nuestro dominio, como el _**API Gateway**_.
* **Múltiples procesos**: Representan un conjunto de subprocesos que pueden descomponerse en otro DFD de menor nivel.
* **Almacenes de datos**: Lugares donde se guarda la información. En nuestro caso, sería la **base de datos**.
* **Flujos de datos**: Conexiones que representan el movimiento de información, por ejemplo, de la **aplicación móvil al _API Gateway_**.
* **Límites de privilegio / confianza**: Fronteras que muestran un cambio en los niveles de acceso. Para este caso de estudio, sería la **frontera de Internet entre la aplicación móvil y el _API Gateway_**.


.Símbolos utilizados en DFDs para modelado de amenazas
[cols="1,2", options="header"]
|===
| Nombre | Descripción

| Entidad Externa | Representa cualquier entidad fuera de la aplicación que interactúa con ella mediante un punto de entrada.

| Proceso | Representa una tarea que maneja datos dentro de la aplicación. El proceso puede modificar o procesar los datos.

| Múltiples Procesos | Representa un conjunto de subprocesos que pueden descomponerse en otro DFD de menor nivel.

| Almacén de Datos | Representa ubicaciones donde se almacenan datos. No modifica los datos, solo los guarda.

| Flujo de Datos | Representa el movimiento de datos dentro de la aplicación. La dirección del flujo se indica con la flecha.

| Límite de Privilegio / Confianza | Representa un cambio de nivel de confianza a medida que los datos fluyen a través de la aplicación.
|===


image::external_entity.png[Entidad Externa]

image::process.png[Proceso]

image::multiple_process.png[Múltiples Procesos]

image::data_store.png[Almacén de Datos]

image::data_flow.png[Flujo de Datos]

image::privilege_boundary.png[Límite de Privilegio / Confianza]

A continuación se muestra un ejemplo de un Diagrama de Flujo de Datos para la API REST del sistema de salud descrito anteriormente.

.Diagrama de Flujo de Datos para la API REST del sistema de salud
image::dfd_heal_rest.png[Diagrama de Flujo de Datos para la API REST del sistema de salud]


===== Paso 2 — Determinar las amenazas (Aplicación de STRIDE)

A partir de la descomposición realizada en el paso anterior, se identifican y analizan las amenazas aplicando las categorías de STRIDE sobre los componentes más relevantes del sistema.

Aunque en este caso se utiliza STRIDE, se puede optar por cualquier otra taxonomía de amenazas que se considere adecuada.

====== Análisis de amenazas

El análisis de amenazas consiste en la identificación de amenazas para la aplicación, e implica examinar cada aspecto de la funcionalidad, arquitectura y diseño de la misma. Es importante identificar y clasificar posibles debilidades que podrían ser explotadas.

Desde la perspectiva defensiva, la identificación de amenazas basada en la categorización de controles de seguridad permite al analista enfocarse en vulnerabilidades específicas. Típicamente, el proceso de identificación de amenazas involucra ciclos iterativos en los cuales, inicialmente, se evalúan todas las amenazas posibles de la lista de amenazas que se aplican a cada componente.

====== Árbol de amenazas

El árbol de amenazas es un método estructurado y sistemático para analizar y comprender posibles amenazas de seguridad. Se utiliza ampliamente en ciberseguridad, evaluación de riesgos y modelado de amenazas para identificar cómo un atacante podría comprometer un sistema y para determinar las estrategias de mitigación más efectivas.

En este enfoque, las amenazas se representan de manera jerárquica en forma de árbol. El nodo principal, o nodo raíz, corresponde al objetivo general del ataque, mientras que las ramas representan diferentes ataques potenciales. Cada rama puede dividirse en sub-ramas, detallando escenarios más específicos o pasos de ataque adicionales. Cada nodo o sub-rama del árbol representa un ataque potencial que podría afectar al sistema.

Este método proporciona una visión integral de los posibles vectores de ataque y facilita la planificación de medidas de mitigación apropiadas, contribuyendo a un análisis de amenazas más completo y sistemático.

A continuación se presentan varios ejemplos de árboles de amenazas aplicados a la API REST del sistema de salud. Cada árbol representa un objetivo potencial del atacante, modelado como el nodo raíz, y muestra de manera jerárquica las vulnerabilidades que podrían ser explotadas para alcanzar dicho objetivo, así como las medidas de mitigación asociadas.

En los diagramas, las vulnerabilidades identificadas se muestran en color rojo, mientras que las contramedidas o mitigaciones propuestas se representan en color verde. Este enfoque permite visualizar de forma clara los posibles vectores de ataque, así como las acciones necesarias para reducir el riesgo y fortalecer la seguridad del sistema.

*Árbol de amenazas 1 – Acceso no autorizado*

Este árbol de amenazas representa el escenario en el que un atacante podría obtener acceso no autorizado a la API REST del sistema de salud. Se identifican vulnerabilidades asociadas a debilidades en los mecanismos de autenticación y autorización, así como al manejo de credenciales y tokens de acceso. Las mitigaciones propuestas buscan reforzar los controles de acceso y reducir el riesgo de suplantación de identidad.

image::arbol1.png[Árbol de amenazas – Acceso no autorizado]


*Árbol de amenazas 2 – Divulgación de información clínica*

En este árbol se analiza la posibilidad de que un atacante divulgue información clínica sensible de pacientes o empleados. Las vulnerabilidades identificadas están relacionadas con fallas en el control de acceso, manejo inseguro de las respuestas del API y ausencia de cifrado adecuado en la comunicación. Las medidas de mitigación se enfocan en preservar la confidencialidad de los datos.

image::arbol2.png[Árbol de amenazas – Divulgación de información clínica]

*Árbol de amenazas 3 – Manipulación de datos clínicos*

Este árbol describe el riesgo de que un atacante modifique información clínica sin autorización, comprometiendo la integridad de los datos del sistema. Las vulnerabilidades consideradas incluyen validación insuficiente de entradas y controles de permisos inadecuados. Las mitigaciones propuestas buscan asegurar la integridad y consistencia de la información clínica.

image::arbol3.png[Árbol de amenazas – Manipulación de datos clínicos]

*Árbol de amenazas 4 – Denegación de servicio*

El presente árbol de amenazas modela el escenario en el que un atacante podría provocar la indisponibilidad de la API REST, afectando la continuidad del servicio clínico. Las vulnerabilidades identificadas se asocian con la falta de control sobre el volumen de solicitudes y el consumo excesivo de recursos. Las mitigaciones planteadas buscan garantizar la disponibilidad del sistema.

image::arbol4.png[Árbol de amenazas – Denegación de servicio]

*Árbol de amenazas 5 – Repudio de acciones*

Este árbol analiza el riesgo de que un atacante o usuario malicioso niegue la realización de acciones dentro del sistema, afectando la trazabilidad y la auditoría. Las vulnerabilidades se centran en la ausencia o debilidad de los mecanismos de registro de eventos. Las mitigaciones propuestas están orientadas a fortalecer la auditoría y la generación de evidencia confiable.

image::arbol5.png[Árbol de amenazas – Repudio de acciones]

A partir del análisis de amenazas y el árbol de amenazas, se documentan las amenazas identificadas en una tabla como la siguiente:

[cols="1,1,1,1,3", options="header"]
|===
|Elemento |Riesgo |Categoría STRIDE |Amenaza |Descripción

|Heal REST API (Proceso)
|Indisponibilidad del servicio
|Denial of Service
|Saturación del API
|Un atacante podría enviar un alto volumen de solicitudes simultáneas al API REST, provocando la indisponibilidad del sistema para usuarios legítimos.

|Login / Autenticación (Proceso)
|Acceso no autorizado
|Spoofing
|Suplantación de identidad
|Un atacante podría autenticarse utilizando credenciales robadas o mediante ataques de fuerza bruta, obteniendo acceso no autorizado al sistema.

|Login / Autenticación (Proceso)
|Escalada de privilegios
|Elevation of Privilege
|Uso indebido de tokens
|Una gestión insegura de tokens de autenticación podría permitir que un atacante reutilice o manipule tokens para acceder a funcionalidades no autorizadas.

|Gestión de Pacientes (Proceso)
|Modificación indebida de datos
|Tampering
|Manipulación de información de pacientes
|Un usuario con permisos insuficientes podría modificar o desactivar registros de pacientes explotando fallas en la validación de permisos.

|Gestión de Historial Clínico (Proceso)
|Divulgación de información sensible
|Information Disclosure
|Exposición de historiales clínicos
|Fallas en los controles de acceso podrían permitir la consulta no autorizada de historiales clínicos que contienen información médica sensible.

|Gestión de Historial Clínico (Proceso)
|Pérdida de trazabilidad
|Repudiation
|Negación de modificaciones
|La ausencia de mecanismos de auditoría adecuados podría permitir que un usuario niegue haber creado o modificado información clínica.

|Gestión de Consultas Médicas (Proceso)
|Alteración de información clínica
|Tampering
|Manipulación de consultas médicas
|Un atacante podría modificar o eliminar consultas médicas sin autorización, afectando la integridad de la información clínica.

|Gestión de Citas (Proceso)
|Alteración de agenda médica
|Tampering
|Manipulación de citas
|Un atacante podría modificar fechas, estados o médicos asignados a citas médicas, afectando la operación del sistema.

|Gestión de Empleados (Proceso)
|Acceso administrativo indebido
|Elevation of Privilege
|Escalada de privilegios
|Fallas en la validación de roles podrían permitir a un usuario obtener privilegios administrativos de forma indebida.

|Flujo de datos HTTP(S) (Flujo de datos)
|Intercepción de información
|Information Disclosure
|Exposición de datos en tránsito
|Las solicitudes y respuestas del API podrían ser interceptadas si no se emplea cifrado TLS adecuado en la comunicación.

|Base de Datos Clínica (Data Store)
|Acceso no autorizado a la información
|Elevation of Privilege
|Ejecución de consultas SQL no autorizadas
|Un atacante podría explotar vulnerabilidades de la aplicación para ejecutar consultas SQL con permisos elevados sobre la base de datos.

|Trust Boundary Usuario–API
|Inyección de datos maliciosos
|Tampering
|Manipulación de datos en frontera de confianza
|Los datos que cruzan la frontera de confianza podrían contener payloads maliciosos si no se valida adecuadamente la información de entrada.
|===


====== Valoración de amenazas

La valoración de amenazas permite priorizar las amenazas identificadas en función de su riesgo y apoyar la estrategia de mitigación. Según OWASP, se pueden clasificar las amenazas usando factores de riesgo cualitativos como probabilidad, impacto y facilidad de explotación [45].

Los pasos para valorar cada amenaza son los siguientes:

. **Evaluar la facilidad de explotación**
- Determinar si un atacante puede explotar la amenaza de manera remota.
- Verificar si se requiere autenticación o privilegios especiales.
- Evaluar si el ataque puede automatizarse.
- Clasificación cualitativa: Baja / Media / Alta

. **Evaluar el impacto**
- Determinar el daño potencial si la amenaza se materializa.
- Considerar qué componentes del sistema se verían afectados.
- Preguntas guía:
  * ¿Puede el atacante tomar control total del sistema?
  * ¿Puede obtener información sensible como datos personales?
  * ¿Puede causar caída o interrupción del servicio?
- Clasificación cualitativa: Bajo / Medio / Alto

. **Evaluar el número de componentes afectados**
- Analizar cuántos sistemas o capas del sistema pueden ser impactados por la amenaza.
- Esto ayuda a dimensionar la extensión del daño potencial.
- Clasificación cualitativa: Bajo / Medio / Alto

. **Determinar el nivel de riesgo**
- El nivel de riesgo se determina tras evaluar los factores anteriores, considerando cuántos bajos, medios o altos hay en cada uno.

En nuestro ejemplo, se tiene la siguiente valoración de amenazas:
//TODO: Incluir tabla de amenazas con valoración de riesgo (Alta, Media, Baja)


===== Paso 3 — Determinar contramedidas y mitigación

Una vez identificadas las amenazas, se definen las contramedidas apropiadas. El propósito de la identificación de contramedidas es determinar si existe algún tipo de medida de protección (por ejemplo, controles de seguridad, políticas) que pueda prevenir que una amenaza se materialice.

[TIP]
====
Aplicar STRIDE sobre los componentes del sistema permite identificar amenazas específicas y asignar contramedidas claras desde las primeras etapas del diseño.
====

Por ejemplo:

* _**Spoofing**_ aplicar autenticación fuerte, MFA y validación de tokens.  
* _**Tampering:**_ cifrar datos en tránsito y validar integridad.  
* _**Repudiation:**_ habilitar registro de auditoría con trazabilidad.  
* _**Information Disclosure:**_ implementar controles de acceso y clasificación de datos.  
* _**Denial of Service:**_ limitar la tasa de peticiones y usar sistemas de detección de anomalías.  
* _**Elevation of Privilege:**_ revisar roles, permisos y aplicar el principio de mínimo privilegio.

Una vez que se han identificado las amenazas y las contramedidas correspondientes, es posible derivar un perfil de amenazas con los siguientes criterios:

* **Amenazas no mitigadas**: Amenazas que no cuentan con contramedidas y representan vulnerabilidades que pueden ser explotadas completamente, causando un impacto.

* **Amenazas parcialmente mitigadas**: Amenazas que están parcialmente mitigadas por una o más contramedidas y que solo pueden ser explotadas de manera parcial, causando un impacto limitado.

* **Amenazas totalmente mitigadas**: Amenazas que tienen contramedidas adecuadas implementadas y no exponen vulnerabilidades.

Siguiendo con el ejemplo, se tiene la siguiente tabla de contramedidas para las amenazas identificadas:

//TODO: Ahora sí se podrían incluir las contramedidas en la tabla del Paso 2. 

Una vez que se han identificado y documentado todo lo anterior, se procede a crear el modelo de amenazas con una herramienta especializada. En nuestro caso, se usará OWASP Threat Dragon.

//TODO: Uso de OWASP Threat Dragon para crear el modelo de amenazas del caso de estudio. Y mostrar capturas de pantalla de la herramienta.

//TODO: Incluir enlace al modelo de amenazas creado en OWASP Threat Dragon.

===== Paso 4 — Evaluar el trabajo

Finalmente, se realiza una evaluación del modelo de amenazas y las mitigaciones propuestas:

* Verificar si se han cubierto todos los componentes y flujos críticos.
* Revisar la coherencia entre las amenazas identificadas y las contramedidas aplicadas.
* Comprobar que las medidas propuestas son viables técnica y económicamente.
* Planificar revisiones periódicas del modelo conforme evolucione la arquitectura del sistema.


[TIP]
====
El modelo de amenazas debe mantenerse como un artefacto vivo que se actualice junto con los cambios de diseño. Su revisión periódica permite detectar nuevos riesgos antes de la fase de implementación.
====


